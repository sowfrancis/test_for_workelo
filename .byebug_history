continue
exit
array
continue
exit
free_times
week - free_times
week
free_times - week
free_times
exit
excluded_time.count
week.count
excluded_time - week
excluded_time + week
week - excluded_time
excluded_time.count
excluded_time
free_times
exit
array.count
array
continue
a.each_slice(2).to_a
a.chunk
a.chunk(1)
a.chunck(1)
a
a.each_slice(2)
a.each_slice(1)
a.each_slice(3)
a.slice(3)
a
continue
excluded
a = week - excluded
excluded
week
a = excluded - week
excluded
exit
a = week - excluded
week
excluded
exit
continue
slot
day
continue
excluded
day
continue
slot
day
continue
excluded
continue
day
d
continue
day
excluded
slot
continue
slot
continue
day
slot
continue
excluded
day
continue
day
slot
continue
excluded
slot
day
excluded
continue
excluded
continue
excluded
continue
day
d
slot
continue
excluded
slot
day
continue
day
slot
excluded
continue
excluded
day
slot
continue
excluded
slot
continue
slot
continue
slot
continue
slot
continue
slot
continue
slot
continue
slot
continue
slot
continue
slot
continue
slot
continue
slot
continue
slot
continue
slot
continue
slot
day
excluded
continue
excluded
continue
excluded
day
continue
excluded
day
continue
day
slot
excluded
continue
day
slot
exit
continue
excluded
day
slot
day
dat
continue
day
excluded
day
hour
slot
day
excluded
continue
excluded
slot
continue
slot
excluded
exit
day
excluded
next
excluded
slot
exit
slot
day
a.to_a
a = (slot.start.to_s..slot.end.to_s)
a.to_a
a = (slot.start.to_s...slot.end.to_s)
a = (slot.start.to_i...slot.end.to_i)
slot.end
p a.to_a
a.to_a
a = (slot.start...slot.end)
(slot.start...slot.end).to_a.split(',')
(slot.start...slot.end).split(',')
(slot.start...slot.end).split()
(slot.start...slot.end).to_a
(slot.start...slot.end).class
slot.start
(slot.start...slot.end).to_a.each {|e| puts e}
(slot.start...slot.end).each {|e| puts e}
d
hour
next
hour
d
exit
h
exit
available_time
(slot.start...slot.end).cover?(hour)
hour
slot
next
busy_slots.each do |key, v|
busy_slots
(slot.start...slot.end).cover?(hour)
hour
available_time
hour
continue
hour
available_time
continue
available_time
slot
continue
slot
available_time
slot
available_time
continue
hour
slot
continue
slot
hour
available_time
continue
slot
exit
available_time
continue
available_time
continue
available_time
hour
available_time
hour
slot
continue
(slot.start...slot.end).cover?(hour)
hour
slot
exit
available_time
available
hour
slot
next
slot != hour
hour
slot
exit
available_time
